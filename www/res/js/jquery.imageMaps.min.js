!function (t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : t("object" == typeof exports ? require("jquery") : jQuery)
}(function (t) {
    "use strict";

    function e(e, s) {
        this.container = t(e), this.mapEl = null, this.svgEl = null, this.options = t.extend(!0, {}, P, s), this.shapeType = this.options.shape, this.isEditMode = this.options.isEditMode, this.shapeStyle = this.options.shapeStyle, this.shapeText = "", this.shapeImageUrl = "", this.shapeCoords = null, this.vertexCoords = null, this.grabType = null, this.containerWidth = 0, this.containerHeight = 0, this.touchStartCoords = {
            x: null,
            y: null
        }, this.dragInfo = {face: {x: null, y: null}, vertex: {x: null, y: null}}, this.shapeLimitCoords = {
            x: 30,
            y: 30,
            radius: 15
        }, this.allShapeInfo = {}
    }

    function s(e, s) {
        var r = k();
        if (this.container.attr("usemap")) {
            var h = this.container.attr("usemap").replace("#", "");
            this.mapEl = t("body").find("map[name=" + h + "]")
        } else this.mapEl = t("<map name=" + r + "></map>").insertAfter(this.container), this.container.attr("usemap", "#" + r);
        this.containerWidth = this.container.width(), this.containerHeight = this.container.height();
        var n = this.containerWidth, p = this.containerHeight, l = n / 2, d = p / 2, c = this.shapeType, f = [], u = !1;
        if (e = M(e), e instanceof Array) c === R.RECT || c === R.IMAGE ? f = t.extend([], Y.rect, e) : c === R.CIRCLE ? f = t.extend([], Y.circle, e) : c === R.ELLIPSE ? f = t.extend([], Y.ellipse, e) : c === R.TEXT ? (e[0] || (e[0] = l, u = !0), e[1] || (e[1] = d, u = !0), e[2] || (e[2] = 20), f = t.extend([], Y.text, e)) : c === R.POLY; else {
            var y = .1 * n, E = .1 * p, g = y >= E ? E : y;
            if (c === R.RECT) f = t.extend([], Y.rect, [l - y, d - E, l + y, d + E]); else if (c === R.CIRCLE) f = t.extend([], Y.circle, [l, d, g]); else if (c === R.ELLIPSE) f = t.extend([], Y.ellipse, [l, d, g, g]); else if (c === R.IMAGE) {
                var v = A(this.shapeImageUrl);
                y = v.width / 2, E = v.height / 2, f = [l - y, d - E, l + y, d + E]
            } else c === R.POLY
        }
        var x = this.mapEl.find("._shape_face").length, m = c, C = {};
        (c === R.TEXT || c === R.IMAGE) && (m = R.RECT, C = c === R.TEXT ? {text: this.shapeText} : {href: this.shapeImageUrl}), a.call(this, f, r, s, x), this.setShapeCoords(f), this.updateShapeInfo(x, {
            coords: f,
            type: c,
            url: s,
            style: this.shapeStyle
        }, C), u && this.isEditMode && c === R.TEXT && o.call(this), c === R.ELLIPSE && (m = R.CIRCLE, f = [f[0], f[1], Y.ellipse[2], Y.ellipse[2]]), i.call(this, m, f, s, x)
    }

    function a(e, s, a, i) {
        var h = this.container.width(), o = this.container.height();
        if ("undefined" != typeof document.createElementNS) {
            var n = this.mapEl.find("svg").get(0), p = t(n), l = this.shapeType;
            n || (n = document.createElementNS(O, "svg"), p = t(n), this.svgEl = p, this.isEditMode ? this.attachEvents(p, [{
                type: "mousedown",
                handler: y
            }]) : this.attachEvents(this.mapEl, [{type: "touchstart", handler: f}, {
                type: "click touchend",
                handler: u
            }]), this.attachEvents(window, [{
                type: "resize",
                handler: v
            }])), n.setAttribute("width", h), n.setAttribute("height", o);
            var d = this.container.position();
            p.attr({xmlns: O, "xmlns:xlink": N, version: "1.1", "data-Id": s}).css({
                position: "absolute",
                zIndex: 1e3,
                overflow: "hidden",
                top: d.top,
                left: d.left
            });
            var c = r.call(this, l, e, a, i);
            p.append(c), this.mapEl.append(p)
        }
    }

    function i(e, s, a, i) {
        t("<area shape=" + e + " coords=" + s.join(",") + " href=" + (a || "#") + " data-index=" + i + " " + (a ? 'target="_blank"' : "") + ">").appendTo(this.mapEl)
    }

    function r(e, s, a, i) {
        e === R.POLY && (e = R.POLYLINE);
        var r = t(document.createElementNS(O, e)), o = t(document.createElementNS(O, "g"));
        h.call(this, s, r);
        var p = "default";
        if (this.isEditMode ? p = "move" : "" !== a && (p = "pointer"), this.setShapeStyle({cursor: p}), r.css(this.shapeStyle), e === R.TEXT && r.css({
            "fill-opacity": "",
            "stroke-opacity": ""
        }), r.attr("data-index", i), o.append(r), this.setShapeElement(r), this.isEditMode && "text" !== e) {
            for (var l = n(e, s, i), d = 0, c = l.length; c > d; d++) l[d].appendTo(o);
            this.setVertexElements(l)
        }
        return o
    }

    function h(t, e, s) {
        e = e || this.shapeEl;
        var a = s ? s.type : this.shapeType;
        a === R.RECT || a === R.IMAGE ? (e.attr({
            x: t[0],
            y: t[1],
            "class": "_shape_face"
        }), t[2] && e.attr("width", t[2] - t[0]), t[3] && e.attr("height", t[3] - t[1]), a === R.IMAGE && (e.get(0).setAttributeNS(N, "href", s ? s.href : this.shapeImageUrl), e.get(0).setAttribute("preserveAspectRatio", "none"))) : a === R.CIRCLE ? (e.attr({
            cx: t[0],
            cy: t[1],
            "class": "_shape_face"
        }), t[2] && e.attr("r", t[2])) : a === R.ELLIPSE ? (e.attr({
            cx: t[0],
            cy: t[1],
            "class": "_shape_face"
        }), t[2] && e.attr("rx", t[2]), t[3] && e.attr("ry", t[3])) : a === R.TEXT ? (e.attr({
            x: t[0],
            y: t[1],
            "font-size": t[2],
            "class": "_shape_face"
        }), e.text(this.shapeText)) : a === R.POLY
    }

    function o() {
        var t = this.shapeEl, e = t.get(0).getBBox(), s = e.width / 2, a = parseFloat(t.attr("font-size")) * X / 2,
            i = parseInt(t.attr("x"), 10), r = parseInt(t.attr("y"), 10), h = i - s, o = r + a;
        this.updateShapeInfo(t.data("index"), {coords: [h, o, t.attr("font-size")]}), t.attr({x: h, y: o})
    }

    function n(e, s, a) {
        for (var i = null, r = [], h = l(e, s), o = 0, n = h.length; n > o; o++) i = t(document.createElementNS(O, "rect")), i.attr("data-index", a).css({
            fill: "#ffffff",
            stroke: "#000000",
            "stroke-width": 2
        }), r.push(i);
        return p(h, r, e), r
    }

    function p(e, s, a) {
        for (var i = 0, r = e.length; r > i; i++) {
            var h = e[i];
            t(s[i]).attr({
                x: h.x - 3,
                y: h.y - 3,
                width: 7,
                height: 7,
                "data-direction": h.type,
                "class": "_shape_vertex"
            }).css("cursor", c(h.type))
        }
    }

    function l(t, e) {
        var s = [];
        return t === R.RECT || t === R.IMAGE ? s = [{x: e[0], y: e[1], type: "nw"}, {
            x: e[0],
            y: e[3],
            type: "sw"
        }, {x: e[2], y: e[1], type: "ne"}, {x: e[2], y: e[3], type: "se"}, {
            x: (e[2] - e[0]) / 2 + e[0],
            y: e[1],
            type: "n"
        }, {x: (e[2] - e[0]) / 2 + e[0], y: e[3], type: "s"}, {
            x: e[0],
            y: (e[3] - e[1]) / 2 + e[1],
            type: "w"
        }, {x: e[2], y: (e[3] - e[1]) / 2 + e[1], type: "e"}] : t === R.CIRCLE ? s = [{
            x: e[0],
            y: e[1] - e[2],
            type: "n"
        }, {x: e[0], y: e[1] + e[2], type: "s"}, {x: e[0] - e[2], y: e[1], type: "w"}, {
            x: e[0] + e[2],
            y: e[1],
            type: "e"
        }] : t === R.ELLIPSE ? s = [{x: e[0], y: e[1] - e[3], type: "n"}, {
            x: e[0],
            y: e[1] + e[3],
            type: "s"
        }, {x: e[0] - e[2], y: e[1], type: "w"}, {x: e[0] + e[2], y: e[1], type: "e"}] : t === R.POLY, s
    }

    function d(t, e, s) {
        var a = this.svgEl.find('._shape_face[data-index="' + e.data("index") + '"]');
        s = s || this.shapeType, s === R.TEXT ? t = b(a) : s === R.ELLIPSE && (t = [t[0], t[1], Y.ellipse[2]]), e.attr("coords", t.join(","))
    }

    function c(t) {
        return t + "-resize"
    }

    function f(t) {
        var e = t.originalEvent.touches[0];
        this.touchStartCoords.x = e.pageX, this.touchStartCoords.y = e.pageY
    }

    function u(e) {
        if ("area" !== e.currentTarget.tagName.toLowerCase()) {
            if (e.preventDefault(), this.dragInfo.face.x && this.dragInfo.face.x !== e.pageX || this.dragInfo.face.y && this.dragInfo.face.y !== e.pageY || "svg" === e.target.tagName.toLowerCase() || "touchend" === e.type && e.originalEvent.changedTouches[0].pageX !== this.touchStartCoords.x && e.originalEvent.changedTouches[0].pageY !== this.touchStartCoords.y) return;
            var s = t(e.target), a = s.attr("data-index"), i = this.mapEl.find('area[data-index="' + a + '"]'),
                r = i.attr("href");
            "#" !== r && window.open(i.attr("href"))
        }
        this.options.onClick.call(this, e, i.attr("href"))
    }

    function y(e) {
        if (e.preventDefault(), "svg" !== e.target.tagName.toLowerCase()) {
            var s = t(e.target), a = s.attr("data-index"), i = this.getShapeInfo(a), r = s.parent(),
                h = r.find(":first-child"), o = [], n = h.get(0).tagName.toLowerCase();
            if (n === R.RECT || n === R.IMAGE) {
                var p = parseInt(h.attr("x"), 10), d = parseInt(h.attr("y"), 10);
                o = [p, d, p + parseInt(h.attr("width"), 10), d + parseInt(h.attr("height"), 10)], n === R.IMAGE && this.setImageShape(h.attr("href"))
            } else if (n === R.CIRCLE) {
                var p = parseInt(h.attr("cx"), 10), d = parseInt(h.attr("cy"), 10);
                o = [p, d, parseInt(h.attr("r"), 10)]
            } else if (n === R.ELLIPSE) {
                var p = parseInt(h.attr("cx"), 10), d = parseInt(h.attr("cy"), 10);
                o = [p, d, parseInt(h.attr("rx"), 10), parseInt(h.attr("ry"), 10)]
            } else if (n === R.TEXT) {
                var p = parseFloat(h.attr("x")), d = parseFloat(h.attr("y")), c = parseFloat(h.attr("font-size"));
                o = [p, d, c]
            } else n === R.POLYGON && (n = R.POLY);
            if (this.setShapeType(n), this.setShapeElement(h), this.setShapeCoords(o), n !== R.TEXT) {
                h.attr("data-fill", h.css("fill")), h.css("fill", "#ffffff"), this.setVertexCoords(l(n, o));
                var f = [], u = this.mapEl.find('._shape_vertex[data-index="' + a + '"]');
                u.each(function () {
                    f.push(t(this))
                }), this.setVertexElements(f)
            }
            s.is("._shape_face") ? (this.grabType = "face", m.call(this, s, e.pageX, e.pageY)) : s.is("._shape_vertex") && (this.grabType = "vertex", S.call(this, s, a)), this.attachEvents(this.mapEl.parent(), [{
                type: "mouseup",
                handler: E
            }, {
                type: "mousemove",
                handler: g
            }]), this.options.onSelect.call(this, e, i), this.options.onMouseDown.call(this, e, n, o)
        }
    }

    function E(e) {
        var s = t(e.target), a = this.shapeEl;
        a.css("fill", a.attr("data-fill")), s.attr("data-movable", !1);
        var i = I.call(this);
        this.setShapeCoords(i), this.updateShapeInfo(a.data("index"), {coords: i}), this.detachEvents(this.mapEl.parent(), [{
            type: "mouseup",
            handler: E
        }, {type: "mousemove", handler: g}]), this.options.onMouseUp.call(this, e, this.shapeType, i)
    }

    function g(e) {
        var s = t(e.target), a = this.shapeCoords[0], i = this.shapeCoords[1], r = this.grabType, o = this.shapeType,
            n = {};
        if ("face" === r || "vertex" === r) {
            if ("face" === r) {
                var l = a + e.pageX, c = i + e.pageY;
                n = C.call(this, l - this.dragInfo.face.x, c - this.dragInfo.face.y)
            } else "vertex" === r && (n = _.call(this, e.pageX - this.svgEl.offset().left, e.pageY - this.svgEl.offset().top));
            o !== R.TEXT && (this.setVertexCoords(n.vertexCoords), p(n.vertexCoords, this.vertexEls, this.shapeType));
            var f = parseInt(n.grabEl.attr("data-index"), 10);
            h.call(this, n.movedCoords, this.svgEl.find('._shape_face[data-index="' + f + '"]')), d.call(this, n.movedCoords, this.mapEl.find('area[data-index="' + f + '"]')), (s.is("._shape_face") || s.is("._shape_vertex")) && (Math.abs(this.dragInfo.face.x - e.pageX) <= 1 || Math.abs(this.dragInfo.face.y - e.pageY) <= 1) && this.svgEl.append(s.parent()), this.options.onMouseMove.call(this, e, o, n.movedCoords)
        }
    }

    function v(t) {
        var e = this.container.width(), s = this.container.height();
        (this.containerWidth !== e || this.containerHeight !== s) && (x.call(this, e, s), this.containerWidth = e, this.containerHeight = s)
    }

    function x(e, s) {
        var a = this, i = this.allShapeInfo, r = e / this.containerWidth, o = s / this.containerHeight;
        this.svgEl.get(0).setAttribute("width", e), this.svgEl.get(0).setAttribute("height", s), t.each(i, function (t, e) {
            e.coords = w(e.coords, e.type, r, o), p(l(e.type, e.coords), a.svgEl.find('._shape_vertex[data-index="' + e.index + '"]'), e.type), h.call(a, e.coords, a.svgEl.find('._shape_face[data-index="' + e.index + '"]'), e), d.call(a, e.coords, a.mapEl.find('area[data-index="' + e.index + '"]'), e.type)
        })
    }

    function m(t, e, s) {
        this.dragInfo.face.x = e, this.dragInfo.face.y = s, t.attr("data-movable", !0)
    }

    function C(t, e) {
        var s = this.shapeEl;
        if ("false" !== s.attr("data-movable")) {
            var a = [], i = [], r = this.shapeType;
            if (r === R.RECT || r === R.IMAGE) {
                var h = parseInt(s.attr("width"), 10), o = parseInt(s.attr("height"), 10), n = t + h, p = e + o;
                a = [t, e, n, p], i = l(R.RECT, a)
            } else r === R.CIRCLE ? (a = [t, e, parseInt(s.attr("r"), 10)], i = l(R.CIRCLE, a)) : r === R.ELLIPSE ? (a = [t, e, parseInt(s.attr("rx"), 10), parseInt(s.attr("ry"), 10)], i = l(R.ELLIPSE, a)) : r === R.TEXT ? a = [t, e] : r === R.POLY;
            return {movedCoords: a, vertexCoords: i, grabEl: s}
        }
    }

    function I() {
        var t = this.shapeEl, e = this.shapeType, s = [];
        if (e === R.RECT || e === R.IMAGE) {
            var a = parseInt(t.attr("x"), 10), i = parseInt(t.attr("y"), 10);
            s = [a, i, a + parseInt(t.attr("width"), 10), i + parseInt(t.attr("height"), 10)]
        } else e === R.CIRCLE ? s = [parseInt(t.attr("cx"), 10), parseInt(t.attr("cy"), 10), parseInt(t.attr("r"), 10)] : e === R.ELLIPSE ? s = [parseInt(t.attr("cx"), 10), parseInt(t.attr("cy"), 10), parseInt(t.attr("rx"), 10), parseInt(t.attr("ry"), 10)] : e === R.TEXT ? s = [parseInt(t.attr("x"), 10), parseInt(t.attr("y"), 10)] : e === R.POLY;
        return s
    }

    function S(t, e) {
        this.setVertexElement(t);
        var s = 0;
        this.vertexEls.forEach(function (e, a) {
            t.get(0) === e.get(0) && (s = a)
        });
        var a = this.vertexCoords[s];
        this.dragInfo.vertex.x = a.x, this.dragInfo.vertex.y = a.y, t.attr("data-movable", !0)
    }

    function _(t, e) {
        if ("false" !== this.vertexEl.attr("data-movable")) {
            var s = [], a = [], i = this.shapeType, r = this.vertexEl.attr("data-direction");
            if (i === R.RECT || i === R.IMAGE) switch (r) {
                case"nw":
                    s = T.call(this, [t, e, this.shapeCoords[2], this.shapeCoords[3]], r);
                    break;
                case"sw":
                    s = T.call(this, [t, this.shapeCoords[1], this.shapeCoords[2], e], r);
                    break;
                case"ne":
                    s = T.call(this, [this.shapeCoords[0], e, t, this.shapeCoords[3]], r);
                    break;
                case"se":
                    s = T.call(this, [this.shapeCoords[0], this.shapeCoords[1], t, e], r);
                    break;
                case"n":
                    s = T.call(this, [this.shapeCoords[0], e, this.shapeCoords[2], this.shapeCoords[3]], r);
                    break;
                case"s":
                    s = T.call(this, [this.shapeCoords[0], this.shapeCoords[1], this.shapeCoords[2], e], r);
                    break;
                case"w":
                    s = T.call(this, [t, this.shapeCoords[1], this.shapeCoords[2], this.shapeCoords[3]], r);
                    break;
                case"e":
                    s = T.call(this, [this.shapeCoords[0], this.shapeCoords[1], t, this.shapeCoords[3]], r)
            } else if (i === R.CIRCLE) switch (r) {
                case"n":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, this.shapeCoords[1] - e)];
                    break;
                case"s":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, e - this.shapeCoords[1])];
                    break;
                case"w":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, this.shapeCoords[0] - t)];
                    break;
                case"e":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, t - this.shapeCoords[0])]
            } else if (i === R.ELLIPSE) switch (r) {
                case"n":
                    s = [this.shapeCoords[0], this.shapeCoords[1], this.shapeCoords[2], L.call(this, this.shapeCoords[1] - e)];
                    break;
                case"s":
                    s = [this.shapeCoords[0], this.shapeCoords[1], this.shapeCoords[2], L.call(this, e - this.shapeCoords[1])];
                    break;
                case"w":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, this.shapeCoords[0] - t), this.shapeCoords[3]];
                    break;
                case"e":
                    s = [this.shapeCoords[0], this.shapeCoords[1], L.call(this, t - this.shapeCoords[0]), this.shapeCoords[3]]
            } else shapetype === R.POLY;
            return a = l(i, s), {movedCoords: s, vertexCoords: a, grabEl: this.vertexEl}
        }
    }

    function T(t, e) {
        var s = t[0], a = t[1], i = t[2], r = t[3];
        return i - s <= this.shapeLimitCoords.x && (("se" === e || "ne" === e || "e" === e) && (i = s + this.shapeLimitCoords.x), ("nw" === e || "sw" === e || "w" === e) && (s = i - this.shapeLimitCoords.x)), r - a <= this.shapeLimitCoords.y && (("se" === e || "sw" === e || "s" === e) && (r = a + this.shapeLimitCoords.y), ("nw" === e || "ne" === e || "n" === e) && (a = r - this.shapeLimitCoords.y)), [s, a, i, r]
    }

    function L(t) {
        var e = this.shapeCoords[2];
        return e = t <= this.shapeLimitCoords.radius ? this.shapeLimitCoords.radius : t
    }

    function w(t, e, s, a) {
        var i = [];
        if (e === R.RECT || e === R.IMAGE || e === R.ELLIPSE) i = [t[0] * s, t[1] * a, t[2] * s, t[3] * a]; else if (e === R.CIRCLE) {
            var r = 1;
            r = s >= a ? a : s, 1 === s && (r = a), 1 === a && (r = s), i = [t[0] * s, t[1] * a, t[2] * r]
        } else e === R.TEXT ? i = [t[0] * s, t[1] * a, t[2] * s] : e === R.POLY;
        return i
    }

    function b(t) {
        var e = parseFloat(t.attr("x")), s = parseFloat(t.attr("y")), a = t.get(0).getBBox(), i = a.width,
            r = parseFloat(t.attr("font-size")) * X / 2;
        return [e, s - r, e + i, s]
    }

    function M(t) {
        if (!t) return null;
        for (var e = [], s = 0, a = t.length; a > s; s++) e.push(parseFloat(t[s]));
        return e
    }

    function k() {
        function t() {
            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1)
        }

        return t() + t() + "-" + t() + "-" + t() + "-" + t() + "-" + t() + t() + t()
    }

    function A(t) {
        var e = new Image;
        return "naturalWidth" in e && "string" != typeof t ? {
            width: t.naturalWidth,
            height: t.naturalHeight
        } : (e.src = t.src || t, {width: e.width, height: e.height})
    }

    var R = {
            RECT: "rect",
            CIRCLE: "circle",
            ELLIPSE: "ellipse",
            TEXT: "text",
            IMAGE: "image",
            POLY: "poly",
            POLYLINE: "polyline",
            POLYGON: "polygon"
        }, P = {
            isEditMode: !1,
            shape: R.RECT,
            shapeText: "press on link",
            shapeStyle: {fill: "#ffffff", "fill-opacity": .2, stroke: "#ffffff", "stroke-width": 3},
            onClick: t.noop,
            onMouseDown: t.noop,
            onMouseMove: t.noop,
            onMouseUp: t.noop,
            onSelect: t.noop
        }, Y = {rect: [0, 0, 20, 20], circle: [0, 0, 10], ellipse: [0, 0, 5, 5], text: [0, 0, 12]}, X = .5,
        O = "http://www.w3.org/2000/svg", N = "http://www.w3.org/1999/xlink";
    e.prototype.createMaps = function (e, a) {
        var i = this.container.width();
        isNaN(i) || !i ? this.container.one("load", t.proxy(s, this, e, a)) : s.call(this, e, a)
    }, e.prototype.setShapeType = function (t) {
        this.shapeType = t
    }, e.prototype.setShapeStyle = function (e) {
        e = e || {}, this.shapeStyle = t.extend({}, !0, this.shapeStyle, e)
    }, e.prototype.setUrl = function (t, e) {
    }, e.prototype.setTextShape = function (t, e) {
        this.setShapeStyle(e), this.shapeText = t
    }, e.prototype.setImageShape = function (t, e) {
        this.setShapeStyle(e), this.shapeImageUrl = t
    }, e.prototype.addShape = function (t, e, s) {
        !!s && this.setShapeType(s), this.createMaps(t, e)
    }, e.prototype.removeShape = function (t) {
        if (this.shapeEl) {
            "undefined" == typeof t && (t = this.shapeEl.data("index"));
            var e = this.mapEl.find('area[data-index="' + t + '"]'),
                s = this.svgEl.find('._shape_face[data-index="' + t + '"]');
            this.detachEvents(s, [{type: "click touchend"}]), s.parent().remove(), e.remove(), this.removeShapeInfo(t)
        }
    }, e.prototype.removeAllShapes = function () {
        if (this.shapeEl) {
            for (var e = this.svgEl.find("._shape_face"), s = 0, a = e.length; a > s; s++) this.removeShape(t(e[s]).data("index"));
            this.allShapeInfo = {}
        }
    }, e.prototype.removeImageMaps = function () {
        this.removeAllShapes(), this.svgEl && this.svgEl.remove()
    }, e.prototype.updateShapeInfo = function (e, s, a) {
        var i = this.allShapeInfo;
        s.index = e, i["shape" + e] ? i["shape" + e] = t.extend(!0, {}, i["shape" + e], s, a) : i["shape" + e] = t.extend(!0, s, a)
    }, e.prototype.removeShapeInfo = function (t) {
        delete this.allShapeInfo["shape" + t]
    }, e.prototype.getShapeInfo = function (t) {
        return this.allShapeInfo["shape" + t]
    }, e.prototype.getAllShapesInfo = function () {
        return t.extend(!0, {}, this.allShapeInfo)
    }, e.prototype.getCoordsByRatio = function (t, e, s, a) {
        return w(t, e, s, a)
    }, e.prototype.enableClick = function () {
        this.attachEvents(this.svgEl.find("._shape_face"), [{type: "touchstart", handler: f}, {
            type: "click touchend",
            handler: u
        }])
    }, e.prototype.disableClick = function () {
        this.detachEvents(this.svgEl.find("._shape_face"), [{type: "touchstart", handler: f}, {
            type: "click touchend",
            handler: u
        }])
    }, e.prototype.setShapeCoords = function (t) {
        this.shapeCoords = t
    }, e.prototype.setVertexCoords = function (t) {
        this.vertexCoords = t
    }, e.prototype.setShapeElement = function (t) {
        this.shapeEl = t
    }, e.prototype.setVertexElement = function (t) {
        this.vertexEl = t
    }, e.prototype.setVertexElements = function (t) {
        this.vertexEls = t
    }, e.prototype.attachEvents = function (e, s) {
        e = t(e);
        for (var a = 0, i = s.length; i > a; a++) e.on(s[a].type + ".area", t.proxy(s[a].handler, this))
    }, e.prototype.detachEvents = function (e, s) {
        e = t(e);
        for (var a = 0, i = s.length; i > a; a++) {
            var r = s[a].type || "", h = s[a].handler ? t.proxy(s[a].handler, this) : "";
            h ? e.off(r + ".area", h) : e.off(r + ".area")
        }
    }, t.fn.extend({
        createMaps: function (t, e) {
            return this.data("image_maps_inst").createMaps(t, e), this
        }, addShape: function (t, e, s) {
            return this.data("image_maps_inst").addShape(t, e, s), this
        }, removeShape: function (t) {
            return this.data("image_maps_inst").removeShape(t), this
        }, removeAllShapes: function () {
            this.data("image_maps_inst").removeAllShapes()
        }, destroy: function () {
            var t = this.data("image_maps_inst");
            t && (t.removeImageMaps(), delete this.data("image_maps_inst"), this.data("image_maps_inst", null))
        }, setShapeStyle: function (t) {
            return this.data("image_maps_inst").setShapeStyle(t), this
        }, setUrl: function (t, e) {
            return this.data("image_maps_inst").setUrl(t, e), this
        }, setTextShape: function (t, e) {
            return this.data("image_maps_inst").setTextShape(t, e), this
        }, setImageShape: function (t, e) {
            return this.data("image_maps_inst").setImageShape(t, e), this
        }, enableClick: function () {
            this.data("image_maps_inst").enableClick()
        }, disableClick: function () {
            this.data("image_maps_inst").disableClick()
        }, getAllShapes: function () {
            return this.data("image_maps_inst").getAllShapesInfo()
        }, getCoordsByRatio: function (t, e, s, a) {
            return this.data("image_maps_inst").getCoordsByRatio(t, e, s, a)
        }
    }), t.fn.imageMaps = function (t) {
        if (1 === this.length) {
            if (!this.data("image_maps_inst")) {
                var s = new e(this, t);
                return this.data("image_maps_inst", s), s
            }
            return this.data("image_maps_inst")
        }
        if (this.length > 1) throw new Error("Already imageMaps instance has been created.")
    }
});
